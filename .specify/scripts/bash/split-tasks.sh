#!/usr/bin/env bash
# Task splitting utility for large features (>12 tasks)
set -e

TASKS_FILE="$1"
if [ -z "$TASKS_FILE" ] || [ ! -f "$TASKS_FILE" ]; then
    echo "Usage: $0 <tasks.md>" >&2
    echo "Splits tasks.md into multiple files if >12 tasks detected" >&2
    exit 1
fi

# Count tasks in the file
TASK_COUNT=$(grep -c "^\- \[ \] T[0-9]" "$TASKS_FILE" 2>/dev/null || echo "0")

echo "📊 Tasks detected: $TASK_COUNT" >&2

if [ "$TASK_COUNT" -le 12 ]; then
    echo "✅ Task count within limits ($TASK_COUNT <= 12), no splitting required" >&2
    exit 0
fi

echo "⚠️  Task count exceeds limit ($TASK_COUNT > 12), splitting required" >&2

FEATURE_DIR=$(dirname "$TASKS_FILE")
TASKS_PER_FILE=10
TOTAL_FILES=$(((TASK_COUNT + TASKS_PER_FILE - 1) / TASKS_PER_FILE))

echo "📁 Splitting into $TOTAL_FILES files with ~$TASKS_PER_FILE tasks each" >&2

# Extract header and metadata from original tasks.md
HEADER_END=$(grep -n "^## Phase" "$TASKS_FILE" | head -1 | cut -d: -f1)
if [ -z "$HEADER_END" ]; then
    HEADER_END=$(grep -n "^- \[ \] T[0-9]" "$TASKS_FILE" | head -1 | cut -d: -f1)
    HEADER_END=$((HEADER_END - 1))
fi

# Extract header content
sed -n "1,${HEADER_END}p" "$TASKS_FILE" > /tmp/tasks_header.txt

# Extract all tasks
grep "^\- \[ \] T[0-9]" "$TASKS_FILE" > /tmp/all_tasks.txt

# Create split files
CURRENT_FILE=1
TASK_NUMBER=1

while [ $CURRENT_FILE -le $TOTAL_FILES ]; do
    SPLIT_FILE="$FEATURE_DIR/tasks${CURRENT_FILE}.md"
    
    # Copy header to each split file
    cp /tmp/tasks_header.txt "$SPLIT_FILE"
    
    # Add split-specific information
    cat >> "$SPLIT_FILE" << EOF

**TASK SPLIT $CURRENT_FILE of $TOTAL_FILES**
**Tasks**: $(((CURRENT_FILE - 1) * TASKS_PER_FILE + 1))-$((CURRENT_FILE * TASKS_PER_FILE > TASK_COUNT ? TASK_COUNT : CURRENT_FILE * TASKS_PER_FILE)) of $TASK_COUNT total
**Dependencies**: tasks$((CURRENT_FILE - 1)).md must complete before this file starts (if exists)

## Critical Rules
- **Complete Previous First**: tasks$((CURRENT_FILE - 1)).md must be 100% complete before starting this file
- **Sequential Execution**: Do not run tasks from multiple split files in parallel
- **Test Dependencies**: Ensure all tests from previous splits pass before proceeding

EOF
    
    # Add tasks for this split
    START_TASK=$(((CURRENT_FILE - 1) * TASKS_PER_FILE + 1))
    END_TASK=$((CURRENT_FILE * TASKS_PER_FILE))
    if [ $END_TASK -gt $TASK_COUNT ]; then
        END_TASK=$TASK_COUNT
    fi
    
    sed -n "${START_TASK},${END_TASK}p" /tmp/all_tasks.txt >> "$SPLIT_FILE"
    
    # Add completion tracking
    cat >> "$SPLIT_FILE" << EOF

## Split Completion Status
- [ ] All tasks in this file completed
- [ ] All tests passing
- [ ] Ready for next split (tasks$((CURRENT_FILE + 1)).md)

**Next Steps**: After completing all tasks above, proceed to tasks$((CURRENT_FILE + 1)).md (if it exists)
EOF
    
    echo "✅ Created: $SPLIT_FILE (tasks $START_TASK-$END_TASK)" >&2
    
    CURRENT_FILE=$((CURRENT_FILE + 1))
done

# Backup original tasks.md
mv "$TASKS_FILE" "$TASKS_FILE.backup"

# Create a master tasks.md file that references the splits
cat > "$TASKS_FILE" << EOF
# Tasks: [FEATURE NAME] - SPLIT EXECUTION

**Original Task Count**: $TASK_COUNT (exceeds 12-task limit)
**Split Files**: $TOTAL_FILES files with ~$TASKS_PER_FILE tasks each
**Execution Order**: Sequential - complete each file before moving to next

## Execution Flow

**CRITICAL**: These files must be executed in strict sequential order:

EOF

for i in $(seq 1 $TOTAL_FILES); do
    TASK_RANGE_START=$(((i - 1) * TASKS_PER_FILE + 1))
    TASK_RANGE_END=$((i * TASKS_PER_FILE))
    if [ $TASK_RANGE_END -gt $TASK_COUNT ]; then
        TASK_RANGE_END=$TASK_COUNT
    fi
    
    cat >> "$TASKS_FILE" << EOF
### $i. tasks${i}.md
- **Tasks**: T$TASK_RANGE_START - T$TASK_RANGE_END
- **Status**: ⏳ Pending
- **Prerequisites**: $([ $i -eq 1 ] && echo "None" || echo "tasks$((i-1)).md must be complete")

EOF
done

cat >> "$TASKS_FILE" << EOF

## Split Rules
1. **Sequential Only**: Never run tasks from multiple split files in parallel
2. **Complete Before Next**: Finish all tasks in current split before moving to next
3. **Test All Phases**: Run tests after each split completion
4. **Dependency Chain**: Each split builds on previous splits

## Recovery
- Original tasks.md backed up as: tasks.md.backup
- To restore: \`mv tasks.md.backup tasks.md\`
- Individual splits preserved for reference

---
**Generated by**: .specify/scripts/bash/split-tasks.sh
**Split Date**: $(date +"%Y-%m-%d %H:%M:%S")
EOF

# Cleanup temp files
rm -f /tmp/tasks_header.txt /tmp/all_tasks.txt

echo "" >&2
echo "🎯 Task splitting complete!" >&2
echo "📋 Master file: $TASKS_FILE" >&2
echo "📁 Split files: tasks1.md through tasks${TOTAL_FILES}.md" >&2
echo "💾 Backup: $TASKS_FILE.backup" >&2
echo "" >&2
echo "⚠️  IMPORTANT: Execute split files sequentially, never in parallel!" >&2