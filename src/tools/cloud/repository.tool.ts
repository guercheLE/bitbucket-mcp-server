/**
 * Cloud Repository Tools
 * Ferramentas para gerenciamento de reposit√≥rios no Bitbucket Cloud
 */

import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { createPool, Pool } from 'generic-pool';
import { RepositoryService } from '../../services/cloud/repository.service.js';
import { ApiClient } from '../../utils/api-client.util.js';
import { Logger } from '../../utils/logger.util.js';
import { createMcpResponse, createErrorResponse } from '../../services/types/base.types.js';
import { z } from 'zod';

// Zod schemas for parameter validation
const GetRepositorySchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const ListRepositoriesSchema = z.object({
  role: z.string().optional(),
  q: z.string().optional(),
  sort: z.string().optional(),
  page: z.number().optional(),
  pagelen: z.number().optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const ListWorkspaceRepositoriesSchema = z.object({
  workspace: z.string(),
  role: z.string().optional(),
  q: z.string().optional(),
  sort: z.string().optional(),
  page: z.number().optional(),
  pagelen: z.number().optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const CreateRepositorySchema = z.object({
  workspace: z.string(),
  name: z.string(),
  description: z.string().optional(),
  scm: z.string().optional(),
  website: z.string().optional(),
  isPrivate: z.boolean().optional(),
  forkPolicy: z.string().optional(),
  hasIssues: z.boolean().optional(),
  hasWiki: z.boolean().optional(),
  project: z.object({}).optional(),
  language: z.string().optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const UpdateRepositorySchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  name: z.string().optional(),
  description: z.string().optional(),
  website: z.string().optional(),
  isPrivate: z.boolean().optional(),
  forkPolicy: z.string().optional(),
  language: z.string().optional(),
  hasIssues: z.boolean().optional(),
  hasWiki: z.boolean().optional(),
  project: z.object({}).optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const DeleteRepositorySchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const ForkRepositorySchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  name: z.string().optional(),
  description: z.string().optional(),
  isPrivate: z.boolean().optional(),
  forkPolicy: z.string().optional(),
  hasIssues: z.boolean().optional(),
  hasWiki: z.boolean().optional(),
  project: z.object({}).optional(),
  language: z.string().optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const ListForksSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  role: z.string().optional(),
  q: z.string().optional(),
  sort: z.string().optional(),
  page: z.number().optional(),
  pagelen: z.number().optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const ListBranchesSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  q: z.string().optional(),
  sort: z.string().optional(),
  page: z.number().optional(),
  pagelen: z.number().optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const GetBranchSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  name: z.string(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const CreateBranchSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  name: z.string(),
  target: z.string(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const DeleteBranchSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  name: z.string(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const ListTagsSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  q: z.string().optional(),
  sort: z.string().optional(),
  page: z.number().optional(),
  pagelen: z.number().optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const ListCommitsSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  include: z.string().optional(),
  exclude: z.string().optional(),
  q: z.string().optional(),
  sort: z.string().optional(),
  page: z.number().optional(),
  pagelen: z.number().optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const GetCommitSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  commit: z.string(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const GetTagSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  name: z.string(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const CreateTagSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  name: z.string(),
  target: z.string(),
  message: z.string().optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const DeleteTagSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  name: z.string(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const ListWebhooksSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  page: z.number().optional(),
  pagelen: z.number().optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const GetWebhookSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  webhookUuid: z.string(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const CreateWebhookSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  description: z.string(),
  url: z.string(),
  active: z.boolean().optional(),
  events: z.array(z.string()),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const UpdateWebhookSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  webhookUuid: z.string(),
  description: z.string().optional(),
  url: z.string().optional(),
  active: z.boolean().optional(),
  events: z.array(z.string()).optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const DeleteWebhookSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  webhookUuid: z.string(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const ListVariablesSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  page: z.number().optional(),
  pagelen: z.number().optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const GetVariableSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  variableUuid: z.string(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const CreateVariableSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  key: z.string(),
  value: z.string(),
  secured: z.boolean().optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const UpdateVariableSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  variableUuid: z.string(),
  key: z.string().optional(),
  value: z.string().optional(),
  secured: z.boolean().optional(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

const DeleteVariableSchema = z.object({
  workspace: z.string(),
  repoSlug: z.string(),
  variableUuid: z.string(),
  output: z.enum(['markdown', 'json']).optional().default('json'),
});

/**
 * Repository Tools for Bitbucket Cloud
 *
 * Comprehensive repository management including:
 * - Get repository information
 * - List repositories
 * - Create, update, delete repositories
 * - Fork repositories
 * - Manage branches and tags
 * - Manage webhooks and variables
 */
export class CloudRepositoryTools {
  private static logger = Logger.forContext('CloudRepositoryTools');
  private static repositoryServicePool: Pool<RepositoryService>;

  static initialize(): void {
    const repositoryServiceFactory = {
      create: async () =>
        new RepositoryService(new ApiClient(), Logger.forContext('RepositoryService')),
      destroy: async () => {},
    };

    this.repositoryServicePool = createPool(repositoryServiceFactory, { min: 2, max: 10 });
    this.logger.info('Cloud Repository tools initialized');
  }

  /**
   * Get Repository
   */
  static async getRepository(
    workspace: string,
    repoSlug: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('getRepository');
    let repositoryService = null;

    try {
      methodLogger.debug('Getting repository:', { workspace, repoSlug });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.getRepository(workspace, repoSlug);

      methodLogger.debug('Successfully retrieved repository');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to get repository:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * List Repositories
   */
  static async listRepositories(
    role?: string,
    q?: string,
    sort?: string,
    page?: number,
    pagelen?: number,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('listRepositories');
    let repositoryService = null;

    try {
      methodLogger.debug('Listing repositories:', { role, q, sort, page, pagelen });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.listRepositories({
        role: role as any,
        q,
        sort: sort as any,
        page,
        pagelen,
      });

      methodLogger.debug('Successfully listed repositories');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to list repositories:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * List Workspace Repositories
   */
  static async listWorkspaceRepositories(
    workspace: string,
    role?: string,
    q?: string,
    sort?: string,
    page?: number,
    pagelen?: number,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('listWorkspaceRepositories');
    let repositoryService = null;

    try {
      methodLogger.debug('Listing workspace repositories:', {
        workspace,
        role,
        q,
        sort,
        page,
        pagelen,
      });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.listWorkspaceRepositories(workspace, {
        role: role as any,
        q,
        sort: sort as any,
        page,
        pagelen,
      });

      methodLogger.debug('Successfully listed workspace repositories');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to list workspace repositories:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Create Repository
   */
  static async createRepository(
    workspace: string,
    name: string,
    description?: string,
    scm?: string,
    website?: string,
    isPrivate?: boolean,
    forkPolicy?: string,
    hasIssues?: boolean,
    hasWiki?: boolean,
    project?: any,
    language?: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('createRepository');
    let repositoryService = null;

    try {
      methodLogger.debug('Creating repository:', { workspace, name });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.createRepository(workspace, {
        name,
        description,
        scm: scm as any,
        website,
        is_private: isPrivate,
        fork_policy: forkPolicy as any,
        has_issues: hasIssues,
        has_wiki: hasWiki,
        project,
      });

      methodLogger.debug('Successfully created repository');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to create repository:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Update Repository
   */
  static async updateRepository(
    workspace: string,
    repoSlug: string,
    name?: string,
    description?: string,
    website?: string,
    isPrivate?: boolean,
    forkPolicy?: string,
    hasIssues?: boolean,
    hasWiki?: boolean,
    project?: any,
    language?: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('updateRepository');
    let repositoryService = null;

    try {
      methodLogger.debug('Updating repository:', { workspace, repoSlug });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.updateRepository(workspace, repoSlug, {
        name,
        description,
        website,
        is_private: isPrivate,
        fork_policy: forkPolicy as any,
        has_issues: hasIssues,
        has_wiki: hasWiki,
        project,
      });

      methodLogger.debug('Successfully updated repository');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to update repository:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Delete Repository
   */
  static async deleteRepository(
    workspace: string,
    repoSlug: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('deleteRepository');
    let repositoryService = null;

    try {
      methodLogger.debug('Deleting repository:', { workspace, repoSlug });
      repositoryService = await this.repositoryServicePool.acquire();

      await repositoryService.deleteRepository(workspace, repoSlug);

      methodLogger.debug('Successfully deleted repository');
      return createMcpResponse({ success: true }, output);
    } catch (error) {
      methodLogger.error('Failed to delete repository:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Fork Repository
   */
  static async forkRepository(
    workspace: string,
    repoSlug: string,
    name?: string,
    description?: string,
    isPrivate?: boolean,
    forkPolicy?: string,
    hasIssues?: boolean,
    hasWiki?: boolean,
    project?: any,
    language?: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('forkRepository');
    let repositoryService = null;

    try {
      methodLogger.debug('Forking repository:', { workspace, repoSlug });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.forkRepository(workspace, repoSlug, {
        name,
        description,
        is_private: isPrivate,
        fork_policy: forkPolicy as any,
        has_issues: hasIssues,
        has_wiki: hasWiki,
        project,
      });

      methodLogger.debug('Successfully forked repository');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to fork repository:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * List Repository Forks
   */
  static async listRepositoryForks(
    workspace: string,
    repoSlug: string,
    role?: string,
    q?: string,
    sort?: string,
    page?: number,
    pagelen?: number,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('listRepositoryForks');
    let repositoryService = null;

    try {
      methodLogger.debug('Listing repository forks:', {
        workspace,
        repoSlug,
        role,
        q,
        sort,
        page,
        pagelen,
      });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.listRepositoryForks(workspace, repoSlug, {
        role: role as any,
        q,
        sort: sort as any,
        page,
        pagelen,
      });

      methodLogger.debug('Successfully listed repository forks');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to list repository forks:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * List Repository Branches
   */
  static async listRepositoryBranches(
    workspace: string,
    repoSlug: string,
    q?: string,
    sort?: string,
    page?: number,
    pagelen?: number,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('listRepositoryBranches');
    let repositoryService = null;

    try {
      methodLogger.debug('Listing repository branches:', {
        workspace,
        repoSlug,
        q,
        sort,
        page,
        pagelen,
      });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.listRepositoryBranches(workspace, repoSlug, {
        q,
        sort: sort as any,
        page,
        pagelen,
      });

      methodLogger.debug('Successfully listed repository branches');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to list repository branches:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Get Repository Branch
   */
  static async getRepositoryBranch(
    workspace: string,
    repoSlug: string,
    branchName: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('getRepositoryBranch');
    let repositoryService = null;

    try {
      methodLogger.debug('Getting repository branch:', { workspace, repoSlug, branchName });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.getRepositoryBranch(workspace, repoSlug, branchName);

      methodLogger.debug('Successfully retrieved repository branch');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to get repository branch:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Create Repository Branch
   */
  static async createRepositoryBranch(
    workspace: string,
    repoSlug: string,
    name: string,
    targetHash: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('createRepositoryBranch');
    let repositoryService = null;

    try {
      methodLogger.debug('Creating repository branch:', { workspace, repoSlug, name, targetHash });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.createRepositoryBranch(workspace, repoSlug, {
        name,
        target: { hash: targetHash },
      });

      methodLogger.debug('Successfully created repository branch');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to create repository branch:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Delete Repository Branch
   */
  static async deleteRepositoryBranch(
    workspace: string,
    repoSlug: string,
    branchName: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('deleteRepositoryBranch');
    let repositoryService = null;

    try {
      methodLogger.debug('Deleting repository branch:', { workspace, repoSlug, branchName });
      repositoryService = await this.repositoryServicePool.acquire();

      await repositoryService.deleteRepositoryBranch(workspace, repoSlug, branchName);

      methodLogger.debug('Successfully deleted repository branch');
      return createMcpResponse({ success: true }, output);
    } catch (error) {
      methodLogger.error('Failed to delete repository branch:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * List Repository Tags
   */
  static async listRepositoryTags(
    workspace: string,
    repoSlug: string,
    q?: string,
    sort?: string,
    page?: number,
    pagelen?: number,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('listRepositoryTags');
    let repositoryService = null;

    try {
      methodLogger.debug('Listing repository tags:', {
        workspace,
        repoSlug,
        q,
        sort,
        page,
        pagelen,
      });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.listRepositoryTags(workspace, repoSlug, {
        q,
        sort: sort as any,
        page,
        pagelen,
      });

      methodLogger.debug('Successfully listed repository tags');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to list repository tags:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Get Repository Tag
   */
  static async getRepositoryTag(
    workspace: string,
    repoSlug: string,
    tagName: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('getRepositoryTag');
    let repositoryService = null;

    try {
      methodLogger.debug('Getting repository tag:', { workspace, repoSlug, tagName });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.getRepositoryTag(workspace, repoSlug, tagName);

      methodLogger.debug('Successfully retrieved repository tag');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to get repository tag:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Create Repository Tag
   */
  static async createRepositoryTag(
    workspace: string,
    repoSlug: string,
    name: string,
    targetHash: string,
    message?: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('createRepositoryTag');
    let repositoryService = null;

    try {
      methodLogger.debug('Creating repository tag:', {
        workspace,
        repoSlug,
        name,
        targetHash,
        message,
      });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.createRepositoryTag(workspace, repoSlug, {
        name,
        target: { hash: targetHash },
        message,
      });

      methodLogger.debug('Successfully created repository tag');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to create repository tag:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Delete Repository Tag
   */
  static async deleteRepositoryTag(
    workspace: string,
    repoSlug: string,
    tagName: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('deleteRepositoryTag');
    let repositoryService = null;

    try {
      methodLogger.debug('Deleting repository tag:', { workspace, repoSlug, tagName });
      repositoryService = await this.repositoryServicePool.acquire();

      await repositoryService.deleteRepositoryTag(workspace, repoSlug, tagName);

      methodLogger.debug('Successfully deleted repository tag');
      return createMcpResponse({ success: true }, output);
    } catch (error) {
      methodLogger.error('Failed to delete repository tag:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * List Repository Commits
   */
  static async listRepositoryCommits(
    workspace: string,
    repoSlug: string,
    include?: string,
    exclude?: string,
    q?: string,
    sort?: string,
    page?: number,
    pagelen?: number,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('listRepositoryCommits');
    let repositoryService = null;

    try {
      methodLogger.debug('Listing repository commits:', {
        workspace,
        repoSlug,
        include,
        exclude,
        q,
        sort,
        page,
        pagelen,
      });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.listRepositoryCommits(workspace, repoSlug, {
        include,
        exclude,
        q,
        sort: sort as any,
        page,
        pagelen,
      });

      methodLogger.debug('Successfully listed repository commits');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to list repository commits:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Get Repository Commit
   */
  static async getRepositoryCommit(
    workspace: string,
    repoSlug: string,
    commit: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('getRepositoryCommit');
    let repositoryService = null;

    try {
      methodLogger.debug('Getting repository commit:', { workspace, repoSlug, commit });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.getRepositoryCommit(workspace, repoSlug, commit);

      methodLogger.debug('Successfully retrieved repository commit');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to get repository commit:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * List Repository Webhooks
   */
  static async listRepositoryWebhooks(
    workspace: string,
    repoSlug: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('listRepositoryWebhooks');
    let repositoryService = null;

    try {
      methodLogger.debug('Listing repository webhooks:', { workspace, repoSlug });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.listRepositoryWebhooks(workspace, repoSlug);

      methodLogger.debug('Successfully listed repository webhooks');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to list repository webhooks:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Get Repository Webhook
   */
  static async getRepositoryWebhook(
    workspace: string,
    repoSlug: string,
    hookUid: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('getRepositoryWebhook');
    let repositoryService = null;

    try {
      methodLogger.debug('Getting repository webhook:', { workspace, repoSlug, hookUid });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.getRepositoryWebhook(workspace, repoSlug, hookUid);

      methodLogger.debug('Successfully retrieved repository webhook');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to get repository webhook:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Create Repository Webhook
   */
  static async createRepositoryWebhook(
    workspace: string,
    repoSlug: string,
    url: string,
    description: string,
    events: string[],
    active?: boolean,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('createRepositoryWebhook');
    let repositoryService = null;

    try {
      methodLogger.debug('Creating repository webhook:', {
        workspace,
        repoSlug,
        url,
        description,
        events,
        active,
      });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.createRepositoryWebhook(workspace, repoSlug, {
        url,
        description,
        events,
        active,
      });

      methodLogger.debug('Successfully created repository webhook');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to create repository webhook:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Update Repository Webhook
   */
  static async updateRepositoryWebhook(
    workspace: string,
    repoSlug: string,
    hookUid: string,
    url?: string,
    description?: string,
    events?: string[],
    active?: boolean,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('updateRepositoryWebhook');
    let repositoryService = null;

    try {
      methodLogger.debug('Updating repository webhook:', {
        workspace,
        repoSlug,
        hookUid,
        url,
        description,
        events,
        active,
      });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.updateRepositoryWebhook(workspace, repoSlug, hookUid, {
        url,
        description,
        events,
        active,
      });

      methodLogger.debug('Successfully updated repository webhook');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to update repository webhook:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Delete Repository Webhook
   */
  static async deleteRepositoryWebhook(
    workspace: string,
    repoSlug: string,
    hookUid: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('deleteRepositoryWebhook');
    let repositoryService = null;

    try {
      methodLogger.debug('Deleting repository webhook:', { workspace, repoSlug, hookUid });
      repositoryService = await this.repositoryServicePool.acquire();

      await repositoryService.deleteRepositoryWebhook(workspace, repoSlug, hookUid);

      methodLogger.debug('Successfully deleted repository webhook');
      return createMcpResponse({ success: true }, output);
    } catch (error) {
      methodLogger.error('Failed to delete repository webhook:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * List Repository Variables
   */
  static async listRepositoryVariables(
    workspace: string,
    repoSlug: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('listRepositoryVariables');
    let repositoryService = null;

    try {
      methodLogger.debug('Listing repository variables:', { workspace, repoSlug });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.listRepositoryVariables(workspace, repoSlug);

      methodLogger.debug('Successfully listed repository variables');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to list repository variables:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Get Repository Variable
   */
  static async getRepositoryVariable(
    workspace: string,
    repoSlug: string,
    variableUuid: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('getRepositoryVariable');
    let repositoryService = null;

    try {
      methodLogger.debug('Getting repository variable:', { workspace, repoSlug, variableUuid });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.getRepositoryVariable(
        workspace,
        repoSlug,
        variableUuid
      );

      methodLogger.debug('Successfully retrieved repository variable');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to get repository variable:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Create Repository Variable
   */
  static async createRepositoryVariable(
    workspace: string,
    repoSlug: string,
    key: string,
    value: string,
    secured?: boolean,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('createRepositoryVariable');
    let repositoryService = null;

    try {
      methodLogger.debug('Creating repository variable:', { workspace, repoSlug, key, secured });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.createRepositoryVariable(workspace, repoSlug, {
        key,
        value,
        secured,
      });

      methodLogger.debug('Successfully created repository variable');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to create repository variable:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Update Repository Variable
   */
  static async updateRepositoryVariable(
    workspace: string,
    repoSlug: string,
    variableUuid: string,
    key?: string,
    value?: string,
    secured?: boolean,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('updateRepositoryVariable');
    let repositoryService = null;

    try {
      methodLogger.debug('Updating repository variable:', {
        workspace,
        repoSlug,
        variableUuid,
        key,
        secured,
      });
      repositoryService = await this.repositoryServicePool.acquire();

      const result = await repositoryService.updateRepositoryVariable(
        workspace,
        repoSlug,
        variableUuid,
        {
          key,
          value,
          secured,
        }
      );

      methodLogger.debug('Successfully updated repository variable');
      return createMcpResponse(result, output);
    } catch (error) {
      methodLogger.error('Failed to update repository variable:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Delete Repository Variable
   */
  static async deleteRepositoryVariable(
    workspace: string,
    repoSlug: string,
    variableUuid: string,
    output: 'markdown' | 'json' = 'markdown'
  ) {
    const methodLogger = this.logger.forMethod('deleteRepositoryVariable');
    let repositoryService = null;

    try {
      methodLogger.debug('Deleting repository variable:', { workspace, repoSlug, variableUuid });
      repositoryService = await this.repositoryServicePool.acquire();

      await repositoryService.deleteRepositoryVariable(workspace, repoSlug, variableUuid);

      methodLogger.debug('Successfully deleted repository variable');
      return createMcpResponse({ success: true }, output);
    } catch (error) {
      methodLogger.error('Failed to delete repository variable:', error);
      if (repositoryService) {
        this.repositoryServicePool.destroy(repositoryService);
        repositoryService = null;
      }
      return createErrorResponse(error instanceof Error ? error.message : 'Unknown error occurred');
    } finally {
      if (repositoryService) {
        this.repositoryServicePool.release(repositoryService);
      }
    }
  }

  /**
   * Register all repository tools with the MCP server
   */
  static register(server: McpServer): void {
    const registerLogger = this.logger.forMethod('register');

    // Initialize the service
    this.initialize();

    // Register get repository tool
    server.registerTool(
      'repository_get',
      {
        description: `Obt√©m informa√ß√µes de um reposit√≥rio espec√≠fico no Bitbucket Cloud.

**Funcionalidades:**
- Informa√ß√µes completas do reposit√≥rio
- Detalhes do workspace e propriet√°rio
- Configura√ß√µes de privacidade e funcionalidades
- Links e metadados do reposit√≥rio

**Par√¢metros:**
- \`workspace\`: Workspace contendo o reposit√≥rio
- \`repoSlug\`: Slug/nome do reposit√≥rio
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes detalhadas do reposit√≥rio incluindo configura√ß√µes, links e metadados.`,
        inputSchema: GetRepositorySchema.shape,
      },
      async (params: z.infer<typeof GetRepositorySchema>) => {
        const validatedParams = GetRepositorySchema.parse(params);
        return this.getRepository(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.output
        );
      }
    );

    // Register list repositories tool
    server.registerTool(
      'repository_list',
      {
        description: `Lista reposit√≥rios no Bitbucket Cloud.

**Funcionalidades:**
- Lista todos os reposit√≥rios acess√≠veis
- Filtros por papel do usu√°rio
- Busca por nome ou descri√ß√£o
- Ordena√ß√£o e pagina√ß√£o

**Par√¢metros:**
- \`role\`: Filtro por papel (owner, admin, contributor, member) (opcional)
- \`q\`: Query de busca (opcional)
- \`sort\`: Campo para ordena√ß√£o (created_on, updated_on, size, name) (opcional)
- \`page\`: N√∫mero da p√°gina para pagina√ß√£o (opcional)
- \`pagelen\`: N√∫mero de itens por p√°gina (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Lista paginada de reposit√≥rios com informa√ß√µes b√°sicas.`,
        inputSchema: ListRepositoriesSchema.shape,
      },
      async (params: z.infer<typeof ListRepositoriesSchema>) => {
        const validatedParams = ListRepositoriesSchema.parse(params);
        return this.listRepositories(
          validatedParams.role,
          validatedParams.q,
          validatedParams.sort,
          validatedParams.page,
          validatedParams.pagelen,
          validatedParams.output
        );
      }
    );

    // Register list workspace repositories tool
    server.registerTool(
      'repository_list_workspace',
      {
        description: `Lista reposit√≥rios de um workspace espec√≠fico no Bitbucket Cloud.

**Funcionalidades:**
- Lista reposit√≥rios de um workspace espec√≠fico
- Filtros por papel do usu√°rio
- Busca por nome ou descri√ß√£o
- Ordena√ß√£o e pagina√ß√£o

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`role\`: Filtro por papel (owner, admin, contributor, member) (opcional)
- \`q\`: Query de busca (opcional)
- \`sort\`: Campo para ordena√ß√£o (created_on, updated_on, size, name) (opcional)
- \`page\`: N√∫mero da p√°gina para pagina√ß√£o (opcional)
- \`pagelen\`: N√∫mero de itens por p√°gina (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Lista paginada de reposit√≥rios do workspace especificado.`,
        inputSchema: ListWorkspaceRepositoriesSchema.shape,
      },
      async (params: z.infer<typeof ListWorkspaceRepositoriesSchema>) => {
        const validatedParams = ListWorkspaceRepositoriesSchema.parse(params);
        return this.listWorkspaceRepositories(
          validatedParams.workspace,
          validatedParams.role,
          validatedParams.q,
          validatedParams.sort,
          validatedParams.page,
          validatedParams.pagelen,
          validatedParams.output
        );
      }
    );

    // Register create repository tool
    server.registerTool(
      'repository_create',
      {
        description: `Cria um novo reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Cria√ß√£o de reposit√≥rio com configura√ß√µes personalizadas
- Configura√ß√£o de privacidade e funcionalidades
- Associa√ß√£o com projetos
- Configura√ß√£o de pol√≠ticas de fork

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`name\`: Nome do reposit√≥rio
- \`description\`: Descri√ß√£o do reposit√≥rio (opcional)
- \`scm\`: Sistema de controle de vers√£o (git) (opcional)
- \`website\`: Website do reposit√≥rio (opcional)
- \`isPrivate\`: Se o reposit√≥rio √© privado (opcional)
- \`forkPolicy\`: Pol√≠tica de fork (allow_forks, no_public_forks, no_forks) (opcional)
- \`hasIssues\`: Se o reposit√≥rio tem issues habilitadas (opcional)
- \`hasWiki\`: Se o reposit√≥rio tem wiki habilitada (opcional)
- \`project\`: Projeto associado ao reposit√≥rio (opcional)
- \`language\`: Linguagem principal do reposit√≥rio (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes do reposit√≥rio criado incluindo configura√ß√µes e links.`,
        inputSchema: CreateRepositorySchema.shape,
      },
      async (params: z.infer<typeof CreateRepositorySchema>) => {
        const validatedParams = CreateRepositorySchema.parse(params);
        return this.createRepository(
          validatedParams.workspace,
          validatedParams.name,
          validatedParams.description,
          validatedParams.scm,
          undefined, // website
          validatedParams.isPrivate,
          validatedParams.forkPolicy,
          validatedParams.hasIssues,
          validatedParams.hasWiki,
          undefined, // project
          validatedParams.language,
          validatedParams.output
        );
      }
    );

    // Register update repository tool
    server.registerTool(
      'repository_update',
      {
        description: `Atualiza um reposit√≥rio existente no Bitbucket Cloud.

**Funcionalidades:**
- Atualiza√ß√£o de configura√ß√µes do reposit√≥rio
- Modifica√ß√£o de privacidade e funcionalidades
- Altera√ß√£o de associa√ß√£o com projetos
- Atualiza√ß√£o de pol√≠ticas de fork

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`name\`: Nome do reposit√≥rio (opcional)
- \`description\`: Descri√ß√£o do reposit√≥rio (opcional)
- \`website\`: Website do reposit√≥rio (opcional)
- \`isPrivate\`: Se o reposit√≥rio √© privado (opcional)
- \`forkPolicy\`: Pol√≠tica de fork (allow_forks, no_public_forks, no_forks) (opcional)
- \`hasIssues\`: Se o reposit√≥rio tem issues habilitadas (opcional)
- \`hasWiki\`: Se o reposit√≥rio tem wiki habilitada (opcional)
- \`project\`: Projeto associado ao reposit√≥rio (opcional)
- \`language\`: Linguagem principal do reposit√≥rio (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes atualizadas do reposit√≥rio.`,
        inputSchema: UpdateRepositorySchema.shape,
      },
      async (params: z.infer<typeof UpdateRepositorySchema>) => {
        const validatedParams = UpdateRepositorySchema.parse(params);
        return this.updateRepository(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.name,
          validatedParams.description,
          undefined, // website not in schema
          validatedParams.isPrivate,
          validatedParams.forkPolicy,
          validatedParams.hasIssues,
          validatedParams.hasWiki,
          undefined, // project not in schema
          validatedParams.language,
          validatedParams.output
        );
      }
    );

    // Register delete repository tool
    server.registerTool(
      'repository_delete',
      {
        description: `Exclui um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Exclus√£o permanente do reposit√≥rio
- Remo√ß√£o de todos os dados associados
- Opera√ß√£o irrevers√≠vel

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Confirma√ß√£o da exclus√£o do reposit√≥rio.`,
        inputSchema: DeleteRepositorySchema.shape,
      },
      async (params: z.infer<typeof DeleteRepositorySchema>) => {
        const validatedParams = DeleteRepositorySchema.parse(params);
        return this.deleteRepository(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.output
        );
      }
    );

    // Register fork repository tool
    server.registerTool(
      'repository_fork',
      {
        description: `Faz fork de um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Cria√ß√£o de fork com configura√ß√µes personalizadas
- Configura√ß√£o de privacidade do fork
- Associa√ß√£o com projetos
- Configura√ß√£o de funcionalidades

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio original
- \`name\`: Nome do reposit√≥rio fork (opcional)
- \`description\`: Descri√ß√£o do reposit√≥rio fork (opcional)
- \`isPrivate\`: Se o reposit√≥rio fork √© privado (opcional)
- \`forkPolicy\`: Pol√≠tica de fork (allow_forks, no_public_forks, no_forks) (opcional)
- \`hasIssues\`: Se o reposit√≥rio fork tem issues habilitadas (opcional)
- \`hasWiki\`: Se o reposit√≥rio fork tem wiki habilitada (opcional)
- \`project\`: Projeto associado ao reposit√≥rio fork (opcional)
- \`language\`: Linguagem principal do reposit√≥rio fork (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes do reposit√≥rio fork criado.`,
        inputSchema: ForkRepositorySchema.shape,
      },
      async (params: z.infer<typeof ForkRepositorySchema>) => {
        const validatedParams = ForkRepositorySchema.parse(params);
        return this.forkRepository(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.name,
          validatedParams.description,
          validatedParams.isPrivate,
          validatedParams.forkPolicy,
          validatedParams.hasIssues,
          validatedParams.hasWiki,
          validatedParams.project,
          validatedParams.language,
          validatedParams.output
        );
      }
    );

    // Register list repository forks tool
    server.registerTool(
      'repository_list_forks',
      {
        description: `Lista os forks de um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Lista todos os forks do reposit√≥rio
- Filtros por papel do usu√°rio
- Busca por nome ou descri√ß√£o
- Ordena√ß√£o e pagina√ß√£o

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`role\`: Filtro por papel (owner, admin, contributor, member) (opcional)
- \`q\`: Query de busca (opcional)
- \`sort\`: Campo para ordena√ß√£o (created_on, updated_on, size, name) (opcional)
- \`page\`: N√∫mero da p√°gina para pagina√ß√£o (opcional)
- \`pagelen\`: N√∫mero de itens por p√°gina (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Lista paginada de forks do reposit√≥rio.`,
        inputSchema: ListForksSchema.shape,
      },
      async (params: z.infer<typeof ListForksSchema>) => {
        const validatedParams = ListForksSchema.parse(params);
        return this.listRepositoryForks(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.role,
          validatedParams.q,
          validatedParams.sort,
          validatedParams.page,
          validatedParams.pagelen,
          validatedParams.output
        );
      }
    );

    // Register list repository branches tool
    server.registerTool(
      'repository_list_branches',
      {
        description: `Lista as branches de um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Lista todas as branches do reposit√≥rio
- Busca por nome de branch
- Ordena√ß√£o por nome ou target
- Pagina√ß√£o

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`q\`: Query de busca (opcional)
- \`sort\`: Campo para ordena√ß√£o (name, -name, target, -target) (opcional)
- \`page\`: N√∫mero da p√°gina para pagina√ß√£o (opcional)
- \`pagelen\`: N√∫mero de itens por p√°gina (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Lista paginada de branches do reposit√≥rio.`,
        inputSchema: ListBranchesSchema.shape,
      },
      async (params: z.infer<typeof ListBranchesSchema>) => {
        const validatedParams = ListBranchesSchema.parse(params);
        return this.listRepositoryBranches(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.q,
          validatedParams.sort,
          validatedParams.page,
          validatedParams.pagelen,
          validatedParams.output
        );
      }
    );

    // Register get repository branch tool
    server.registerTool(
      'repository_get_branch',
      {
        description: `Obt√©m informa√ß√µes de uma branch espec√≠fica no Bitbucket Cloud.

**Funcionalidades:**
- Informa√ß√µes detalhadas da branch
- Detalhes do commit target
- Links para commits e hist√≥rico

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`name\`: Nome da branch
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes detalhadas da branch incluindo target e links.`,
        inputSchema: GetBranchSchema.shape,
      },
      async (params: z.infer<typeof GetBranchSchema>) => {
        const validatedParams = GetBranchSchema.parse(params);
        return this.getRepositoryBranch(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.name,
          validatedParams.output
        );
      }
    );

    // Register create repository branch tool
    server.registerTool(
      'repository_create_branch',
      {
        description: `Cria uma nova branch em um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Cria√ß√£o de branch a partir de um commit espec√≠fico
- Configura√ß√£o do commit target
- Valida√ß√£o de nomes de branch

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`name\`: Nome da nova branch
- \`target\`: Hash do commit target
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes da branch criada incluindo target e links.`,
        inputSchema: CreateBranchSchema.shape,
      },
      async (params: z.infer<typeof CreateBranchSchema>) => {
        const validatedParams = CreateBranchSchema.parse(params);
        return this.createRepositoryBranch(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.name,
          validatedParams.target,
          validatedParams.output
        );
      }
    );

    // Register delete repository branch tool
    server.registerTool(
      'repository_delete_branch',
      {
        description: `Exclui uma branch de um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Exclus√£o permanente da branch
- Valida√ß√£o de permiss√µes
- Opera√ß√£o irrevers√≠vel

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`name\`: Nome da branch a ser exclu√≠da
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Confirma√ß√£o da exclus√£o da branch.`,
        inputSchema: DeleteBranchSchema.shape,
      },
      async (params: z.infer<typeof DeleteBranchSchema>) => {
        const validatedParams = DeleteBranchSchema.parse(params);
        return this.deleteRepositoryBranch(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.name,
          validatedParams.output
        );
      }
    );

    // Register list repository tags tool
    server.registerTool(
      'repository_list_tags',
      {
        description: `Lista as tags de um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Lista todas as tags do reposit√≥rio
- Busca por nome de tag
- Ordena√ß√£o por nome ou target
- Pagina√ß√£o

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`q\`: Query de busca (opcional)
- \`sort\`: Campo para ordena√ß√£o (name, -name, target, -target) (opcional)
- \`page\`: N√∫mero da p√°gina para pagina√ß√£o (opcional)
- \`pagelen\`: N√∫mero de itens por p√°gina (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Lista paginada de tags do reposit√≥rio.`,
        inputSchema: ListTagsSchema.shape,
      },
      async (params: z.infer<typeof ListTagsSchema>) => {
        const validatedParams = ListTagsSchema.parse(params);
        return this.listRepositoryTags(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.q,
          validatedParams.sort,
          validatedParams.page,
          validatedParams.pagelen,
          validatedParams.output
        );
      }
    );

    // Register get repository tag tool
    server.registerTool(
      'repository_get_tag',
      {
        description: `Obt√©m informa√ß√µes de uma tag espec√≠fica no Bitbucket Cloud.

**Funcionalidades:**
- Informa√ß√µes detalhadas da tag
- Detalhes do commit target
- Links para commits e hist√≥rico

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`name\`: Nome da tag
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes detalhadas da tag incluindo target e links.`,
        inputSchema: GetTagSchema.shape,
      },
      async (params: z.infer<typeof GetTagSchema>) => {
        const validatedParams = GetTagSchema.parse(params);
        return this.getRepositoryTag(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.name,
          validatedParams.output
        );
      }
    );

    // Register create repository tag tool
    server.registerTool(
      'repository_create_tag',
      {
        description: `Cria uma nova tag em um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Cria√ß√£o de tag a partir de um commit espec√≠fico
- Configura√ß√£o do commit target
- Mensagem opcional para a tag
- Valida√ß√£o de nomes de tag

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`name\`: Nome da nova tag
- \`target\`: Hash do commit target
- \`message\`: Mensagem da tag (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes da tag criada incluindo target e links.`,
        inputSchema: CreateTagSchema.shape,
      },
      async (params: z.infer<typeof CreateTagSchema>) => {
        const validatedParams = CreateTagSchema.parse(params);
        return this.createRepositoryTag(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.name,
          validatedParams.target,
          validatedParams.message,
          validatedParams.output
        );
      }
    );

    // Register delete repository tag tool
    server.registerTool(
      'repository_delete_tag',
      {
        description: `Exclui uma tag de um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Exclus√£o permanente da tag
- Valida√ß√£o de permiss√µes
- Opera√ß√£o irrevers√≠vel

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`name\`: Nome da tag a ser exclu√≠da
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Confirma√ß√£o da exclus√£o da tag.`,
        inputSchema: DeleteTagSchema.shape,
      },
      async (params: z.infer<typeof DeleteTagSchema>) => {
        const validatedParams = DeleteTagSchema.parse(params);
        return this.deleteRepositoryTag(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.name,
          validatedParams.output
        );
      }
    );

    // Register list repository commits tool
    server.registerTool(
      'repository_list_commits',
      {
        description: `Lista os commits de um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Lista commits do reposit√≥rio
- Filtros por include/exclude
- Busca por mensagem de commit
- Ordena√ß√£o e pagina√ß√£o

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`include\`: Incluir commits espec√≠ficos (opcional)
- \`exclude\`: Excluir commits espec√≠ficos (opcional)
- \`q\`: Query de busca (opcional)
- \`sort\`: Campo para ordena√ß√£o (target, -target) (opcional)
- \`page\`: N√∫mero da p√°gina para pagina√ß√£o (opcional)
- \`pagelen\`: N√∫mero de itens por p√°gina (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Lista paginada de commits do reposit√≥rio.`,
        inputSchema: ListCommitsSchema.shape,
      },
      async (params: z.infer<typeof ListCommitsSchema>) => {
        const validatedParams = ListCommitsSchema.parse(params);
        return this.listRepositoryCommits(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.include,
          validatedParams.exclude,
          validatedParams.q,
          validatedParams.sort,
          validatedParams.page,
          validatedParams.pagelen,
          validatedParams.output
        );
      }
    );

    // Register get repository commit tool
    server.registerTool(
      'repository_get_commit',
      {
        description: `Obt√©m informa√ß√µes de um commit espec√≠fico no Bitbucket Cloud.

**Funcionalidades:**
- Informa√ß√µes detalhadas do commit
- Detalhes do autor e mensagem
- Links para diff e patch
- Informa√ß√µes dos commits pais

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`commit\`: Hash do commit
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes detalhadas do commit incluindo autor, mensagem e links.`,
        inputSchema: GetCommitSchema.shape,
      },
      async (params: z.infer<typeof GetCommitSchema>) => {
        const validatedParams = GetCommitSchema.parse(params);
        return this.getRepositoryCommit(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.commit,
          validatedParams.output
        );
      }
    );

    // Register list repository webhooks tool
    server.registerTool(
      'repository_list_webhooks',
      {
        description: `Lista os webhooks de um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Lista todos os webhooks do reposit√≥rio
- Informa√ß√µes de configura√ß√£o
- Status ativo/inativo

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Lista de webhooks do reposit√≥rio com configura√ß√µes.`,
        inputSchema: ListWebhooksSchema.shape,
      },
      async (params: z.infer<typeof ListWebhooksSchema>) => {
        const validatedParams = ListWebhooksSchema.parse(params);
        return this.listRepositoryWebhooks(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.output
        );
      }
    );

    // Register get repository webhook tool
    server.registerTool(
      'repository_get_webhook',
      {
        description: `Obt√©m informa√ß√µes de um webhook espec√≠fico no Bitbucket Cloud.

**Funcionalidades:**
- Informa√ß√µes detalhadas do webhook
- Configura√ß√µes de eventos
- Status e URLs
- Metadados de cria√ß√£o

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`webhookUuid\`: UUID do webhook
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes detalhadas do webhook incluindo configura√ß√µes e status.`,
        inputSchema: GetWebhookSchema.shape,
      },
      async (params: z.infer<typeof GetWebhookSchema>) => {
        const validatedParams = GetWebhookSchema.parse(params);
        return this.getRepositoryWebhook(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.webhookUuid,
          validatedParams.output
        );
      }
    );

    // Register create repository webhook tool
    server.registerTool(
      'repository_create_webhook',
      {
        description: `Cria um novo webhook em um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Cria√ß√£o de webhook com configura√ß√µes personalizadas
- Configura√ß√£o de eventos
- URLs de callback
- Status ativo/inativo

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`url\`: URL do webhook
- \`description\`: Descri√ß√£o do webhook
- \`events\`: Lista de eventos (array de strings)
- \`active\`: Se o webhook est√° ativo (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes do webhook criado incluindo configura√ß√µes e UID.`,
        inputSchema: CreateWebhookSchema.shape,
      },
      async (params: z.infer<typeof CreateWebhookSchema>) => {
        const validatedParams = CreateWebhookSchema.parse(params);
        return this.createRepositoryWebhook(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.url,
          validatedParams.description,
          validatedParams.events,
          validatedParams.active,
          validatedParams.output
        );
      }
    );

    // Register update repository webhook tool
    server.registerTool(
      'repository_update_webhook',
      {
        description: `Atualiza um webhook existente em um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Atualiza√ß√£o de configura√ß√µes do webhook
- Modifica√ß√£o de eventos
- Altera√ß√£o de URLs
- Ativa√ß√£o/desativa√ß√£o

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`webhookUuid\`: UUID do webhook
- \`url\`: Nova URL do webhook (opcional)
- \`description\`: Nova descri√ß√£o do webhook (opcional)
- \`events\`: Nova lista de eventos (opcional)
- \`active\`: Novo status ativo/inativo (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes atualizadas do webhook.`,
        inputSchema: UpdateWebhookSchema.shape,
      },
      async (params: z.infer<typeof UpdateWebhookSchema>) => {
        const validatedParams = UpdateWebhookSchema.parse(params);
        return this.updateRepositoryWebhook(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.webhookUuid,
          validatedParams.url,
          validatedParams.description,
          validatedParams.events,
          validatedParams.active,
          validatedParams.output
        );
      }
    );

    // Register delete repository webhook tool
    server.registerTool(
      'repository_delete_webhook',
      {
        description: `Exclui um webhook de um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Exclus√£o permanente do webhook
- Valida√ß√£o de permiss√µes
- Opera√ß√£o irrevers√≠vel

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`webhookUuid\`: UUID do webhook a ser exclu√≠do
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Confirma√ß√£o da exclus√£o do webhook.`,
        inputSchema: DeleteWebhookSchema.shape,
      },
      async (params: z.infer<typeof DeleteWebhookSchema>) => {
        const validatedParams = DeleteWebhookSchema.parse(params);
        return this.deleteRepositoryWebhook(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.webhookUuid,
          validatedParams.output
        );
      }
    );

    // Register list repository variables tool
    server.registerTool(
      'repository_list_variables',
      {
        description: `Lista as vari√°veis de um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Lista todas as vari√°veis do reposit√≥rio
- Informa√ß√µes de seguran√ßa
- Valores e configura√ß√µes

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Lista de vari√°veis do reposit√≥rio com configura√ß√µes.`,
        inputSchema: ListVariablesSchema.shape,
      },
      async (params: z.infer<typeof ListVariablesSchema>) => {
        const validatedParams = ListVariablesSchema.parse(params);
        return this.listRepositoryVariables(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.output
        );
      }
    );

    // Register get repository variable tool
    server.registerTool(
      'repository_get_variable',
      {
        description: `Obt√©m informa√ß√µes de uma vari√°vel espec√≠fica no Bitbucket Cloud.

**Funcionalidades:**
- Informa√ß√µes detalhadas da vari√°vel
- Configura√ß√µes de seguran√ßa
- Valores e metadados

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`variableUuid\`: UUID da vari√°vel
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes detalhadas da vari√°vel incluindo configura√ß√µes e valor.`,
        inputSchema: GetVariableSchema.shape,
      },
      async (params: z.infer<typeof GetVariableSchema>) => {
        const validatedParams = GetVariableSchema.parse(params);
        return this.getRepositoryVariable(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.variableUuid,
          validatedParams.output
        );
      }
    );

    // Register create repository variable tool
    server.registerTool(
      'repository_create_variable',
      {
        description: `Cria uma nova vari√°vel em um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Cria√ß√£o de vari√°vel com configura√ß√µes personalizadas
- Configura√ß√£o de seguran√ßa
- Valores e chaves

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`key\`: Chave da vari√°vel
- \`value\`: Valor da vari√°vel
- \`secured\`: Se a vari√°vel √© segura (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes da vari√°vel criada incluindo configura√ß√µes e UUID.`,
        inputSchema: CreateVariableSchema.shape,
      },
      async (params: z.infer<typeof CreateVariableSchema>) => {
        const validatedParams = CreateVariableSchema.parse(params);
        return this.createRepositoryVariable(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.key,
          validatedParams.value,
          validatedParams.secured,
          validatedParams.output
        );
      }
    );

    // Register update repository variable tool
    server.registerTool(
      'repository_update_variable',
      {
        description: `Atualiza uma vari√°vel existente em um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Atualiza√ß√£o de configura√ß√µes da vari√°vel
- Modifica√ß√£o de valores
- Altera√ß√£o de configura√ß√µes de seguran√ßa

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`variableUuid\`: UUID da vari√°vel
- \`key\`: Nova chave da vari√°vel (opcional)
- \`value\`: Novo valor da vari√°vel (opcional)
- \`secured\`: Nova configura√ß√£o de seguran√ßa (opcional)
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Informa√ß√µes atualizadas da vari√°vel.`,
        inputSchema: UpdateVariableSchema.shape,
      },
      async (params: z.infer<typeof UpdateVariableSchema>) => {
        const validatedParams = UpdateVariableSchema.parse(params);
        return this.updateRepositoryVariable(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.variableUuid,
          validatedParams.key,
          validatedParams.value,
          validatedParams.secured,
          validatedParams.output
        );
      }
    );

    // Register delete repository variable tool
    server.registerTool(
      'repository_delete_variable',
      {
        description: `Exclui uma vari√°vel de um reposit√≥rio no Bitbucket Cloud.

**Funcionalidades:**
- Exclus√£o permanente da vari√°vel
- Valida√ß√£o de permiss√µes
- Opera√ß√£o irrevers√≠vel

**Par√¢metros:**
- \`workspace\`: Nome do workspace
- \`repoSlug\`: Slug do reposit√≥rio
- \`variableUuid\`: UUID da vari√°vel a ser exclu√≠da
- \`output\`: Formato de sa√≠da - 'markdown' ou 'json' (padr√£o)

**Retorna:** Confirma√ß√£o da exclus√£o da vari√°vel.`,
        inputSchema: DeleteVariableSchema.shape,
      },
      async (params: z.infer<typeof DeleteVariableSchema>) => {
        const validatedParams = DeleteVariableSchema.parse(params);
        return this.deleteRepositoryVariable(
          validatedParams.workspace,
          validatedParams.repoSlug,
          validatedParams.variableUuid,
          validatedParams.output
        );
      }
    );

    registerLogger.info('Successfully registered all cloud repository tools');
  }
}
